function mPretty(M)
    % Display matrix M nicely formatted in the command window
    % Supports both symbolic and numeric matrices
    
    if isa(M, 'sym')
        % If M is symbolic, use the 'pretty' function
        pretty(M);
    else
        % If M is numeric, format and display each element
        [rows, cols] = size(M);
        for i = 1:rows
            fprintf('%8.4f ', M(i, :));  % Adjust width and precision as needed
            fprintf('\n');
        end
    end
end
%% 
clc;clear;
variables = { 'T_h', 'Delta_T', 'Delta_T_ext', 'Delta_m_dot_e', 'u_h', ...
    'Delta_T_h', 'Delta_m_dot_i', 'u_bulb', 'L',...
    'c_air', 'A', 'k', 'k_h', 'C', 'C_h', 'P_h', ...
    'P_bulb', 'eff_bulb', };


% Define all variables as symbolic using the list
syms(variables{:});

%%
T_0 = 20;            % Nominal temperature in the room
T_h_0 = 20;          % Nominal temperature of the heating element
T_ext_0 = 20;        % Nominal temperature outside
m_dot_e_0 = 0.001;       % Nominal airflow from outside 
m_dot_i_0 = 0.001;       % Nominal airflow recirculated 

% to be able to linearize the differentials, we redefine the control
% variables to diviations around the nominal values.
T = T_0 + Delta_T;
T_h = T_h_0 + Delta_T_h;
T_ext = T_ext_0 + Delta_T_ext;
m_dot_e = m_dot_e_0 + Delta_m_dot_e;
m_dot_i = m_dot_i_0 + Delta_m_dot_i;

% Define state vector and input vector
ss_X = [Delta_T; Delta_T_h];                                      % states
ss_U = [Delta_T_ext; Delta_m_dot_i; Delta_m_dot_e; u_bulb; u_h];  % inputs / controlled variables
ss_Y = [Delta_T; Delta_T_h; P_bulb * u_bulb * eff_bulb];          % outputs

% Equations for heat change inside the room
Q_loss = k * A * (T - T_ext);                                     % heat loss through the walls
% Q_vent = m_dot_e * c_air * (T_ext - T);                         % heat change from ventillation
Q_vent = m_dot_e_0 * c_air * (Delta_T_ext - Delta_T) + ...
         Delta_m_dot_e * c_air * (T_ext_0 - T_0);
% Q_heat = m_dot_e * c_air * (T_h - T_ext) ...
%          + m_dot_i * c_air * (T_h - T);                         % added heat by heater element
Q_heat = m_dot_e_0 * c_air * (Delta_T_h - Delta_T_ext) + ...
         m_dot_i_0 * c_air * (Delta_T_h - Delta_T) + ...
         Delta_m_dot_e * c_air * (T_h_0 - T_ext_0) + ...
         Delta_m_dot_i * c_air * (T_h_0 - T_0);
Q_bulb = P_bulb * u_bulb * (1 - eff_bulb);                        % Heat generated by bulb

% Light bulb illumination effects
L = P_bulb * u_bulb * eff_bulb;                                   % Illumination output (non-heat energy)

% Room temperature change (dT/dt)
dTdt = (-Q_loss + Q_vent + Q_heat + Q_bulb) / C;
pretty(dTdt);

% Heating element temperature change (dT_h/dt)
Qh_heater = u_h * P_h;
Qh_wall = k_h * (T_h - T_ext);
% Qh_vent = m_dot_e * c_air * (T_ext - T_h) + m_dot_i * c_air * (T - T_h);
Qh_vent = c_air * ( ...
            m_dot_e_0 * Delta_T_ext - ...
            (m_dot_e_0 + m_dot_i_0) * Delta_T_h + ...
            m_dot_i_0 * Delta_T + ...
            (T_ext_0 - T_h_0) * Delta_m_dot_e + ...
            (T_0 - T_h_0) * Delta_m_dot_i ...
          );
dThdt = (Qh_heater - Qh_wall + Qh_vent) / C_h;

% Define f (state derivatives)
ss_f = [dTdt; dThdt];

% clearing up after calculating symbolic equations
clear(variables{:});

%% Parameter values
% System Constants for Room
% a*b*c sized acrylic box

air_density = 1.225;            % kg/m3 
a=0.25;
b=0.25;
c=0.20;
V = a * b * c;                  % m3 air
m_air = V * air_density;        % kg air
A = 2*a*b+2*a*c+2*b*c;          % Surface area of walls (m²)
k = 1;                        % Heat transfer coefficient of walls (W/m²°C)
c_air = 1005;                   % Specific heat capacity of air (J/kg·°C)
C = m_air*c_air;                % Thermal capacitance of air in the box (J/°C)

% Heating Element Constants
C_h = 50;          % Thermal capacitance of heating element (J/°C)
k_h = 1;           % Heat transfer coefficient with environment (W/°C)
P_h = 100;         % Heating power when on (W)

% Light Bulb Parameters (approximating old halogen bulb)
P_bulb = 20;     % Maximum power of bulb (W)
eff_bulb = 0.1;   % Efficiency as light (0.1 for halogen, i.e., 90% as heat, 10% as light)

%% Parameter values (stored in a struct for easy reuse)
params = struct( ...
    'A', A, ...
    'k', k, ...
    'C', C, ...
    'c_air', c_air, ...
    'C_h', C_h, ...
    'k_h', k_h, ...
    'P_h', P_h, ...
    'P_bulb', P_bulb, ...
    'eff_bulb', eff_bulb ...
    );

% Calculate Jacobians symbolically
A_sym = jacobian(ss_f, ss_X);       % System matrix
B_sym = jacobian(ss_f, ss_U);       % Input matrix
C_sym = jacobian(ss_Y, ss_X);       % Output matrix for state response to outputs T and T_h
D_sym = jacobian(ss_Y, ss_U);       % Direct input-output relationship

% Convert struct fields to cell arrays for substitution
paramNames = fieldnames(params);
paramValues = struct2cell(params);

% Substitute values for symbolic matrices
A_num = double(subs(A_sym, paramNames, paramValues));
B_num = double(subs(B_sym, paramNames, paramValues));
C_num = double(subs(C_sym, paramNames, paramValues));
D_num = double(subs(D_sym, paramNames, paramValues));


% Display symbolic state-space matrices
disp('Symbolic A matrix:');
mPretty(A_sym);
disp('Symbolic B matrix:');
mPretty(B_sym);
disp('Symbolic C matrix:');
mPretty(C_sym);
disp('Symbolic D matrix:');
mPretty(D_sym);

% Display numerical state-space matrices
disp('Numeric A matrix:');
mPretty(A_num);
disp('Numeric B matrix:');
mPretty(B_num);
disp('Numeric C matrix:');
mPretty(C_num);
disp('Numeric D matrix:');
mPretty(D_num);

model = ss(A_num, B_num, C_num, D_num);

isstable(model)
pzplot(model)
step(model)