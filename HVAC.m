%% HVAC system university project.
% The protorype is a 20/20/20 cm acrylic box, with some sensors and
% actuators. It is a test environment to test control engineering
% techniques with multiple inputs and outputs.
% The box has an air pipe leading out of the box. On that pipe there is
% first a pair of valves operated by a single motor. This valve allow some
% of the air to be vented to the environment and be replaced by external
% air. If the valve is closed, all air is recirculated, if open, all air is
% vented and external air is drawed in.
% The next component in the pipe is a temperature sensor that measures the
% mixture temperature. This is follower by a heating element, that can
% either be turned on or off, and heats up the mixture. This mixted and
% heated air is then pumped back into the room/box by a motor. This motor's
% speed can be set. Finally, the temperature of this air can also be
% measured.
% There is a temperature sensor inside the box, this is the temperature we
% ultimately want to control. There is also a light sensor in the room
% alongside with an old light bulb. We can also control the light level in
% the room, but we need to pay attention to the fact that the bulb also
% heats up the room.

function mPretty(M)
    % Display matrix M nicely formatted in the command window
    % Supports both symbolic and numeric matrices
    
    if isa(M, 'sym')
        % If M is symbolic, use the 'pretty' function
        pretty(M);
    else
        % If M is numeric, format and display each element
        [rows, cols] = size(M);
        for i = 1:rows
            fprintf('%8.4f ', M(i, :));  % Adjust width and precision as needed
            fprintf('\n');
        end
    end
end
%% Preparing symbolic toolbox
clc;clear;

% All the symbolic variables that are used to define the differential equations
% including inputs, outputs, states and parameters, 
variables = { 'T_h', 'Delta_T', 'Delta_T_ext', 'Delta_m_dot_e', 'u_h', ...
    'Delta_T_h', 'Delta_m_dot_i', 'u_bulb', 'L',...
    'c_air', 'A', 'k', 'k_h', 'C', 'C_h', 'P_h', ...
    'P_bulb', 'eff_bulb', };


% Define all variables as symbolic using the list
syms(variables{:});

%% Assembling the differential equations describing the model
T_0 = 20;            % Nominal temperature in the room
T_h_0 = 20;          % Nominal temperature of the heating element
T_ext_0 = 20;        % Nominal temperature outside
m_dot_e_0 = 0.001;       % Nominal airflow from outside
m_dot_i_0 = 0.001;       % Nominal airflow recirculated

% to be able to linearize the differentials, we redefine the control
% variables to diviations around the nominal values.
T = T_0 + Delta_T;
T_h = T_h_0 + Delta_T_h;
T_ext = T_ext_0 + Delta_T_ext;
m_dot_e = m_dot_e_0 + Delta_m_dot_e;
m_dot_i = m_dot_i_0 + Delta_m_dot_i;

% Equations for heat change inside the room
Q_loss = k * A * (T - T_ext);                                     % heat loss through the walls
Q_vent = m_dot_e * c_air * (T_ext - T);                           % heat change from ventillation
Q_heat = m_dot_e * c_air * (T_h - T_ext) ...
          + m_dot_i * c_air * (T_h - T);                          % added heat by heater element
Q_bulb = P_bulb * u_bulb * (1 - eff_bulb);                        % Heat generated by bulb

% Light bulb illumination effects
L = P_bulb * u_bulb * eff_bulb;                                   % Illumination output (non-heat energy)

% Room temperature change (dT/dt)
dTdt = (-Q_loss + Q_vent + Q_heat + Q_bulb) / C;
pretty(dTdt);

% Heating element temperature change (dT_h/dt)
Qh_heater = u_h * P_h;
Qh_wall = k_h * (T_h - T_ext);
Qh_vent = m_dot_e * c_air * (T_ext - T_h) + m_dot_i * c_air * (T - T_h);
dThdt = (Qh_heater - Qh_wall + Qh_vent) / C_h;

% Define input, output and state vectors, as well as system of differential
% equations
ss_U = [Delta_m_dot_i; Delta_m_dot_e; u_bulb; u_h];  % inputs / controlled variables
ss_X = [Delta_T; Delta_T_h];                                      % states
ss_Y = [Delta_T; Delta_T_h; P_bulb * u_bulb * eff_bulb];          % outputs
% ss_f = [dTdt; dThdt]; % would be if already linear
ss_f = taylor([dTdt; dThdt], [ ...
    Delta_T, Delta_T_h, Delta_T_ext, Delta_m_dot_i, Delta_m_dot_e], ... % which variables are used to linearize
    'ExpansionPoint', ...
    [T_0, T_h_0, T_ext_0, m_dot_e_0, m_dot_i_0], ... % around what poins are they linearized
    'Order', 2);

% clearing up after calculating symbolic equations
clear(variables{:});    % this is needed as these variables are going to be
                        % redefined with values

%% Parameter values
% System Constants for Room
% a*b*c sized acrylic box
a = 0.20; % side of the box (m)
b = 0.20; % side of the box (m)
c = 0.20; % side of the box (m)

air_density = 1.225;            % kg/m3 
V = a * b * c;                  % m3 air
m_air = V * air_density;        % kg air
A = 2*a*b+2*a*c+2*b*c;          % Surface area of walls (m²)
k = 1;                          % Heat transfer coefficient of walls (W/m²°C)
c_air = 1005;                   % Specific heat capacity of air (J/kg·°C)
C = m_air*c_air;                % Thermal capacitance of air in the box (J/°C)

% Heating Element Constants
C_h = 50;          % Thermal capacitance of heating element (J/°C)
k_h = 1;           % Heat transfer coefficient with environment (W/°C)
P_h = 100;         % Heating power when on (W)

% Light Bulb Parameters (approximating old halogen bulb)
P_bulb = 20;     % Maximum power of bulb (W)
eff_bulb = 0.1;   % Efficiency as light (0.1 for halogen, i.e., 90% as heat, 10% as light)

%% Parameter values (stored in a struct for easy reuse)
params = struct( ...
    'A', A, ...
    'k', k, ...
    'C', C, ...
    'c_air', c_air, ...
    'C_h', C_h, ...
    'k_h', k_h, ...
    'P_h', P_h, ...
    'P_bulb', P_bulb, ...
    'eff_bulb', eff_bulb ...
    );

%% Calculating the state space matrices
% Calculate Jacobians symbolically
A_sym = jacobian(ss_f, ss_X);       % System matrix
B_sym = jacobian(ss_f, ss_U);       % Input matrix
C_sym = jacobian(ss_Y, ss_X);       % Output matrix for state response to outputs T and T_h
D_sym = jacobian(ss_Y, ss_U);       % Direct input-output relationship

% Convert struct fields to cell arrays for substitution
paramNames = fieldnames(params);
paramValues = struct2cell(params);

% Substitute values for symbolic matrices
A_num = subs(A_sym, paramNames, paramValues);
B_num = subs(B_sym, paramNames, paramValues);
C_num = subs(C_sym, paramNames, paramValues);
D_num = subs(D_sym, paramNames, paramValues);

% Display symbolic state-space matrices
disp('Symbolic A matrix:');
mPretty(A_sym);
disp('Symbolic B matrix:');
mPretty(B_sym);
disp('Symbolic C matrix:');
mPretty(C_sym);
disp('Symbolic D matrix:');
mPretty(D_sym);

% Display numerical state-space matrices
disp('Numeric A matrix:');
mPretty(A_num);
disp('Numeric B matrix:');
mPretty(B_num);
disp('Numeric C matrix:');
mPretty(C_num);
disp('Numeric D matrix:');
mPretty(D_num);

% needed for using ss()
A_num = double(A_num);
B_num = double(B_num);
C_num = double(C_num);
D_num = double(D_num);

model = ss(A_num, B_num, C_num, D_num);

disp('Is stable:');
isstable(model)
step(model)

disp('Observability matrix:');
obsv(model)
disp('Controlability matrix:');
ctrb(model)

% Check observability
Obs_matrix = obsv(A_num, C_num);
disp('Rank of Observability Matrix:');
disp(rank(Obs_matrix));
if rank(Obs_matrix) < size(A_num, 1)
    error('System is not fully observable.');
end

% Desired observer poles (should be faster than the system poles)
desired_observer_poles = eig(A_num) * 5;  % Place poles 5x faster than system
disp('Desired Observer Poles:');
disp(desired_observer_poles);

% Compute the observer gain (L)
L_num = place(A_num', C_num', desired_observer_poles)';  % Transpose for MATLAB syntax
disp('Observer Gain Matrix L:');
disp(L_num);

% designing LQR controller
% X = [Delta_T; Delta_T_h]  % penatize bad performance
Q = [1 1].*eye(2); 
% U = [Delta_T_ext; Delta_m_dot_i; Delta_m_dot_e; u_bulb; u_h];
% penatize actuator effort
R = [1,1,1,1].*eye(4);

K_num = lqr(A_num, B_num, Q, R);

N_num = [1,1,1,1].*eye(4);