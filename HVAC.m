function mPretty(M)
    % Display matrix M nicely formatted in the command window
    % Supports both symbolic and numeric matrices
    
    if isa(M, 'sym')
        % If M is symbolic, use the 'pretty' function
        pretty(M);
    else
        % If M is numeric, format and display each element
        [rows, cols] = size(M);
        for i = 1:rows
            fprintf('%8.4f ', M(i, :));  % Adjust width and precision as needed
            fprintf('\n');
        end
    end
end
%% 

clc;clear;
variables = {'T', 'T_h', 'T_ext', 'T_env', 'm_dot', 'v', 'c_air', ...
    'A', 'k', 'k_h', 'C', 'C_h', 'u_h', 'P_h', ...
    'P_bulb', 'u_bulb', 'eff_bulb', 'L'};


% Define all variables as symbolic using the list
syms(variables{:});

% Define state vector and input vector
ss_X = [T; T_h];                                % states
ss_U = [T_ext; u_h; v; m_dot; u_bulb];          % inputs / controlled variables
ss_Y = [T; T_h; P_bulb * u_bulb * eff_bulb];    % outputs

% Equations for heat change inside the room
Q_loss = -k * A * (T - T_ext);              % heat loss through the walls
Q_vent = m_dot * c_air * v * (T_ext - T);   % heat change from ventillation
Q_heat = m_dot * c_air * v * (T_h - T);     % added heat by heater element
Q_bulb = P_bulb * u_bulb * (1 - eff_bulb);  % Heat generated by bulb

% Light bulb illumination effects
L = P_bulb * u_bulb * eff_bulb;     % Illumination output (non-heat energy)

% Room temperature change (dT/dt)
dTdt = (Q_loss + Q_vent + Q_heat + Q_bulb) / C;
pretty(dTdt);

% Heating element temperature change (dT_h/dt)
dThdt = (u_h * P_h - k_h * (T_h - T_env) - m_dot * c_air * v * (T_h - T)) / C_h;
pretty(dThdt);

% Define f (state derivatives)
ss_f = [dTdt; dThdt];

% clearing up after calculating symbolic equations
clear(variables{:});

%% Parameter values
% System Constants for Room
A = 10;           % Surface area of walls (m²)
k = 0.5;          % Heat transfer coefficient of walls (W/m²°C)
C = 1000;         % Thermal capacitance of air in the box (J/°C)
c_air = 1005;     % Specific heat capacity of air (J/kg·°C)
T_ext = 20;        % External temperature (°C)

% Heating Element Constants
C_h = 50;         % Thermal capacitance of heating element (J/°C)
k_h = 0.1;        % Heat transfer coefficient with environment (W/°C)
P_h = 200;        % Heating power when on (W)
T_env = 20;       % Environmental temperature (°C)

% Control Variables
v = 1;            % Valve position (fraction of external air, 0≤v≤1)
u_h = 0;          % Heating element control (1 for on, 0 for off)
m_dot = 0.1;      % Mass flow rate of air (kg/s)

% Light Bulb Parameters (approximating old halogen bulb)
P_bulb = 100;   % Maximum power of bulb (W)
eff_bulb = 0.1;     % Efficiency as light (0.1 for halogen, i.e., 90% as heat, 10% as light)
u_bulb = 0.5;       % Control input for brightness (0 to 1 scale)

% Initial Conditions
T_init = 30;      % Initial room temperature (°C)
T_h_init = 30;   % Initial heating element temperature (°C)
initial_conditions = [T_init; T_h_init];


%% Parameter values (stored in a struct for easy reuse)
params = struct( ...
    'A', A, ...
    'k', k, ...
    'C', C, ...
    'c_air', c_air, ...
    'C_h', C_h, ...
    'k_h', k_h, ...
    'P_h', P_h, ...
    'P_bulb', P_bulb, ...
    'eff_bulb', eff_bulb, ...
    'u_bulb', u_bulb ...
    );

% % Verify equations are now numeric
% dTdt_numeric = eval(dTdt);
% dThdt_numeric = eval(dThdt);
% 
% disp('Initial Rate of Room Temperature change:');
% disp(dTdt_numeric);
% disp('Initial Rate of Heating Element Temperature change:');
% disp(dThdt_numeric);

% Convert symbolic equations to numeric function handles

dTdt_func = matlabFunction(dTdt, 'Vars', {'T', 'T_h', 'T_ext', 'm_dot', 'v', 'c_air', 'A', 'k', 'C', 'P_bulb', 'u_bulb', 'eff_bulb'});
dThdt_func = matlabFunction(dThdt, 'Vars', {'T', 'T_h', 'T_env', 'u_h','v', 'P_h', 'k_h', 'm_dot', 'c_air', 'C_h'});

% Define the system of equations for ode45 using these functions
dTdt_system = @(t, X) [
    dTdt_func(X(1), X(2), T_ext, m_dot, v, c_air, A, k, C, P_bulb, u_bulb, eff_bulb);
    dThdt_func(X(1), X(2), T_env, u_h, v, P_h, k_h, m_dot, c_air, C_h);
];

% Define time span for simulation
tspan = [0 1000];

% Use ode45 to simulate the temperature evolution over time
[t, X] = ode45(dTdt_system, tspan, initial_conditions);

% Plot results
figure(1);
clf;
plot(t, X(:, 1), 'DisplayName', 'Room Temperature (T)');
hold on;
plot(t, X(:, 2), 'DisplayName', 'Heating Element Temperature (T_h)');
xlabel('Time (s)');
ylabel('Temperature (°C)');
yyaxis right;
plot(t, P_bulb * u_bulb * eff_bulb * ones(size(t)), 'DisplayName', 'Illumination (L)'); % Static Illumination
ylabel('Illumination (?)');
legend;
title('Temperature Evolution in Room and Heating Element');

% Calculate Jacobians symbolically
A_sym = jacobian(ss_f, ss_X);       % System matrix
B_sym = jacobian(ss_f, ss_U);       % Input matrix
C_sym = jacobian(ss_Y, ss_X);       % Output matrix for state response to outputs T and T_h
D_sym = jacobian(ss_Y, ss_U);       % Direct input-output relationship

% Convert struct fields to cell arrays for substitution
paramNames = fieldnames(params);
paramValues = struct2cell(params);

% Substitute values for symbolic matrices
A_num = subs(A_sym, paramNames, paramValues);
B_num = subs(B_sym, paramNames, paramValues);
C_num = subs(C_sym, paramNames, paramValues);
D_num = subs(D_sym, paramNames, paramValues);

% Display symbolic state-space matrices
disp('Symbolic A matrix:');
mPretty(A_sym);
disp('Symbolic B matrix:');
mPretty(B_sym);
disp('Symbolic C matrix:');
mPretty(C_sym);
disp('Symbolic D matrix:');
mPretty(D_sym);

% Display numerical state-space matrices
disp('Numeric A matrix:');
mPretty(A_num);
disp('Numeric B matrix:');
mPretty(B_num);
disp('Numeric C matrix:');
mPretty(C_num);
disp('Numeric D matrix:');
mPretty(D_num);