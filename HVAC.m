%% HVAC system university project.
% The protorype is a 20/20/20 cm acrylic box, with some sensors and
% actuators. It is a test environment to test control engineering
% techniques with multiple inputs and outputs.
% The box has an air pipe leading out of the box. On that pipe there is
% first a pair of valves operated by a single motor. This valve allow some
% of the air to be vented to the environment and be replaced by external
% air. If the valve is closed, all air is recirculated, if open, all air is
% vented and external air is drawed in.
% The next component in the pipe is a temperature sensor that measures the
% mixture temperature. This is follower by a heating element, that can
% either be turned on or off, and heats up the mixture. This mixted and
% heated air is then pumped back into the room/box by a motor. This motor's
% speed can be set. Finally, the temperature of this air can also be
% measured.
% There is a temperature sensor inside the box, this is the temperature we
% ultimately want to control. There is also a light sensor in the room
% alongside with an old light bulb. We can also control the light level in
% the room, but we need to pay attention to the fact that the bulb also
% heats up the room.

function mPretty(M)
    % Display matrix M nicely formatted in the command window
    % Supports both symbolic and numeric matrices
    
    if isa(M, 'sym')
        % If M is symbolic, use the 'pretty' function
        pretty(M);
    else
        % If M is numeric, format and display each element
        [rows, cols] = size(M);
        for i = 1:rows
            fprintf('%8.4f ', M(i, :));  % Adjust width and precision as needed
            fprintf('\n');
        end
    end
end
%% Preparing symbolic toolbox
clc;clear;

% All the symbolic variables that are used to define the differential equations
% including inputs, outputs, states and parameters, 
variables = { 'T_h', 'T', 'T_ext', 'light', ...
    'm_dot_i', 'm_dot_e', 'u_h', 'u_bulb',...
    'c_air', 'area', 'k', 'k_h', 'C', 'C_h', 'P_h', ...
    'P_bulb', 'eff_bulb', 'alpha'};


% Define all variables as symbolic using the list
syms(variables{:});

%% Assembling the differential equations describing the model
T_0 = 20;                % Nominal temperature in the room
T_h_0 = 20;              % Nominal temperature of the heating element
T_ext_0 = 20;            % Nominal temperature outside
m_dot_e_0 = 0.001;       % Nominal airflow from outside
m_dot_i_0 = 0.001;       % Nominal airflow recirculated

% Equations for heat change inside the room
Q_loss = k * area * (T - T_ext);                    % heat loss through the walls
Q_vent = m_dot_e * c_air * (T_ext - T);             % heat change from ventillation
Q_heat = m_dot_e * c_air * (T_h - T_ext) ...
          + m_dot_i * c_air * (T_h - T);            % added heat by heater element
Q_bulb = P_bulb * u_bulb * (1 - eff_bulb);          % Heat generated by bulb

% Light bulb illumination effects
light = P_bulb * u_bulb * eff_bulb;                 % Illumination output (non-heat energy)

% Room temperature change (dT/dt)
dTdt = (-Q_loss + Q_vent + Q_heat + Q_bulb) / C;

T_vo = (m_dot_e * T_ext + m_dot_i * T) / (m_dot_e + m_dot_i);
T_ho = T_vo + (P_h * u_h)/((m_dot_e + m_dot_i) * c_air);

% Heating element temperature change (dT_h/dt)
Qh_heater = u_h * P_h;
Qh_wall = k_h * (T_h - T_ext);
Qh_vent = m_dot_e * c_air * (T_ext - T_h) + m_dot_i * c_air * (T - T_h);
dThdt = (Qh_heater - Qh_wall + Qh_vent) / C_h;

% Giving the outside temperature some dynamics, as the house can influence
% the temperature right around the room by a tiny bit
dTextdt = alpha * (T - T_ext);

% Define input, output and state vectors, as well as system of differential
% equations
ss_U = [m_dot_i; m_dot_e; u_bulb; u_h];                      % inputs / controlled variables
ss_X = [T; T_h; T_ext];                                      % states
ss_Y = [T; T_h; light];                                      % outputs
% ss_f = [dTdt; dThdt];                                      % would be if already linear
ss_f = taylor([dTdt; dThdt; dTextdt], [ ...
    T, T_h, T_ext, m_dot_i, m_dot_e], ...                    % which variables are used to linearize
    'ExpansionPoint', ...
    [T_0, T_h_0, T_ext_0, m_dot_e_0, m_dot_i_0], ...         % around what poins are they linearized
    'Order', 2);

% Define second state space for plant simulation
plant_U = [T_ext; m_dot_i; m_dot_e; u_bulb; u_h];            % inputs / controlled variables
plant_X = [T; T_h; T_ext];                                   % states
plant_Y = [T; T_vo; T_ho; P_bulb * u_bulb * eff_bulb];       % outputs
plant_f = taylor([dTdt; dThdt; dTextdt], [ ...
    T, T_h, T_ext, m_dot_i, m_dot_e], ...                    % which variables are used to linearize
    'ExpansionPoint', ...
    [T_0, T_h_0, T_ext_0, m_dot_e_0, m_dot_i_0], ...         % around what poins are they linearized
    'Order', 2);

% clearing up after calculating symbolic equations
clear(variables{:});    % this is needed as these variables are going to be
                        % redefined with values

%% Parameter values
% System Constants for Room
% a*b*c sized acrylic box
a = 0.20; % side of the box (m)
b = 0.20; % side of the box (m)
c = 0.20; % side of the box (m)

air_density = 1.225;            % kg/m3 
V = a * b * c;                  % m3 air
m_air = V * air_density;        % kg air
area = 2*a*b+2*a*c+2*b*c;       % Surface area of walls (m²)
k = 1;                          % Heat transfer coefficient of walls (W/m²°C)
c_air = 1005;                   % Specific heat capacity of air (J/kg·°C)
C = m_air * c_air;              % Thermal capacitance of air in the box (J/°C)

% Heating Element Constants
C_h = 50;                       % Thermal capacitance of heating element (J/°C)
k_h = 1;                        % Heat transfer coefficient with environment (W/°C)
P_h = 100;                      % Heating power when on (W)
alpha = 0.0001;                 % small coefficient representing the effect of the house on the outside temperature

% Light Bulb Parameters (approximating old halogen bulb)
P_bulb = 20;                    % Maximum power of bulb (W)
eff_bulb = 0.1;                 % Efficiency as light (0.1 for halogen, i.e., 90% as heat, 10% as light)

%% Parameter values (stored in a struct for easy reuse)
params = struct( ...
    'area', area, ...
    'alpha', alpha, ...
    'k', k, ...
    'C', C, ...
    'c_air', c_air, ...
    'C_h', C_h, ...
    'k_h', k_h, ...
    'P_h', P_h, ...
    'P_bulb', P_bulb, ...
    'eff_bulb', eff_bulb ...
    );

%% Calculating the state space matrices
% Calculate Jacobians symbolically
A_sym = jacobian(ss_f, ss_X);       % System matrix
B_sym = jacobian(ss_f, ss_U);       % Input matrix
C_sym = jacobian(ss_Y, ss_X);       % Output matrix for state response to outputs T and T_h
D_sym = jacobian(ss_Y, ss_U);       % Direct input-output relationship

% Convert struct fields to cell arrays for substitution
paramNames = fieldnames(params);
paramValues = struct2cell(params);

% Substitute values for symbolic matrices
A = subs(A_sym, paramNames, paramValues);
B = subs(B_sym, paramNames, paramValues);
C = subs(C_sym, paramNames, paramValues);
D = subs(D_sym, paramNames, paramValues);

% Calculate plant state space
plant_A = subs(jacobian(plant_f, plant_X), paramNames, paramValues);        % System matrix
plant_B = subs(jacobian(plant_f, plant_U), paramNames, paramValues);        % Input matrix
plant_C = subs(jacobian(plant_Y, plant_X), paramNames, paramValues);        % Output matrix for state response to outputs T and T_h
plant_D = subs(jacobian(plant_Y, plant_U), paramNames, paramValues);        % Direct input-output relationship

% Display symbolic state-space matrices
% disp('Symbolic A matrix:');
% mPretty(A_sym);
% disp('Symbolic B matrix:');
% mPretty(B_sym);
% disp('Symbolic C matrix:');
% mPretty(C_sym);
% disp('Symbolic D matrix:');
% mPretty(D_sym);

% Display numerical state-space matrices
disp('Numeric A matrix:'); mPretty(plant_A);
disp('Numeric B matrix:'); mPretty(plant_B);
disp('Numeric C matrix:'); mPretty(plant_C);
disp('Numeric D matrix:'); mPretty(plant_D); 

% needed for using ss()
A = double(A); plant_A = double(plant_A);
B = double(B); plant_B = double(plant_B);
C = double(C); plant_C = double(plant_C);
D = double(D); plant_D = double(plant_D);

model = ss(A, B, C, D);
model_plant = ss(plant_A, plant_B, plant_C, plant_D);

% if isstable(model) == 0
%     error('System is not stable');
% end
% if isstable(model_plant) == 0
%     error('Plant system is not stable');
% end

step(model)

disp('Observability matrix:');
obsv(model)
disp('Controlability matrix:');
ctrb(model)

% Check observability
Obs_matrix = obsv(A, C);
disp('Rank of Observability Matrix:');
disp(rank(Obs_matrix));
if rank(Obs_matrix) < size(A, 1)
    error('System is not fully observable.');
end

% Desired observer poles (should be faster than the system poles)
desired_observer_poles = eig(A) * 5;  % Place poles 5x faster than system
disp('Desired Observer Poles:');
disp(desired_observer_poles);

% Compute the observer gain (L)
L = place(A', C', desired_observer_poles)';  % Transpose for MATLAB syntax
disp('Observer Gain Matrix L:');
disp(L);

% designing LQR controller
% X = [T; T_h; T_ext]  % penatize bad performance
Q = diag([1 1 1]);
% U = [m_dot_i; m_dot_e; u_bulb; u_h];
% penatize actuator effort
R = diag([1 1 1 1]);

K = lqr(A, B, Q, R)

N = diag([1 1 1 1]);